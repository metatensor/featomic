
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/density-correlations.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_density-correlations.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_density-correlations.py:


Computing density correlations
==============================

.. start-body

.. GENERATED FROM PYTHON SOURCE LINES 7-16

.. code-block:: Python


    import ase.io
    import metatensor as mts
    import numpy as np

    from featomic import SphericalExpansion
    from featomic.clebsch_gordan import DensityCorrelations, EquivariantPowerSpectrum









.. GENERATED FROM PYTHON SOURCE LINES 17-22

Computing the spherical expansion
---------------------------------

We can define the spherical expansion hyper parameters and compute the density.
This will be used throughout the remainder of the tutorial.

.. GENERATED FROM PYTHON SOURCE LINES 23-46

.. code-block:: Python


    HYPER_PARAMETERS = {
        "cutoff": {
            "radius": 5.0,
            "smoothing": {"type": "ShiftedCosine", "width": 0.5},
        },
        "density": {
            "type": "Gaussian",
            "width": 0.3,
        },
        "basis": {
            "type": "TensorProduct",
            "max_angular": 3,
            "radial": {"type": "Gto", "max_radial": 4},
        },
    }

    systems = ase.io.read("dataset.xyz", ":")

    # Initialize the SphericalExpansion calculator and compute the density
    spherical_expansion = SphericalExpansion(**HYPER_PARAMETERS)
    density = spherical_expansion.compute(systems)








.. GENERATED FROM PYTHON SOURCE LINES 47-54

Move to "neighbor_type" to properties, i.e. remove sparsity in this dimension.

Note: this method should be called with care when computing on a subset of systems
from a larger dataset. If the ``systems`` being computed contain a subset of the
global atom types, an inconsistent feature dimension will be created. In this case,
the argument to ``keys_to_properties`` should be specified as a ``Labels`` object with
all global atom types.

.. GENERATED FROM PYTHON SOURCE LINES 55-61

.. code-block:: Python


    density = density.keys_to_properties("neighbor_type")

    # average number of features per block
    print("total number of features:", np.sum([len(block.properties) for block in density]))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    total number of features: 320




.. GENERATED FROM PYTHON SOURCE LINES 62-72

Density correlations to build a :math:`\lambda`-SOAP
----------------------------------------------------

We can now use the ``DensityCorrelations`` calculator and specify that we want to take
a single Clebsch-Gordan (CG) tensor product, i.e. ``n_correlations=1``.

During initialization, the calculator computes and stores the CG coefficients. As the
density expansion is up to ``o3_lambda=3`` and we are doing a single contraction, we
need CG coefficients computed up to ``o3_lambda=6`` in order to do a full contraction.
Hence, we set ``max_angular=6``.

.. GENERATED FROM PYTHON SOURCE LINES 73-79

.. code-block:: Python


    density_correlations = DensityCorrelations(
        n_correlations=1,
        max_angular=6,
    )








.. GENERATED FROM PYTHON SOURCE LINES 80-82

This outputs an equivariant power spectrum descriptor of body-order 3, i.e.
:math:`\lambda`-SOAP features.

.. GENERATED FROM PYTHON SOURCE LINES 83-86

.. code-block:: Python


    lambda_soap = density_correlations.compute(density)








.. GENERATED FROM PYTHON SOURCE LINES 87-96

This is not quite equivalent to the result seen in the previous tutorial on
:ref:`computing λ-SOAP <compute-lambda-soap>`. The keys contain
dimensions ``"l_1"`` and ``"l_2"`` which for a given block track the angular order of
the blocks from the input combined to create the block in the output
:class:`~metatensor.TensorMap`.

Keeping these dimensions in the keys is useful to allow for further CG products to be
taken, building more complex descriptors. For now, we can move these key dimensions to
properties. Inspect the metadata before and after moving these dimensions.

.. GENERATED FROM PYTHON SOURCE LINES 97-101

.. code-block:: Python


    print("λ-SOAP before keys_to_properties:", lambda_soap.keys)
    print("first block:", lambda_soap[0])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    λ-SOAP before keys_to_properties: Labels(
        o3_lambda  o3_sigma  center_type  l_1  l_2
            0         1           1        0    0
            1         1           1        0    1
                           ...
            5         -1          8        3    3
            6         1           8        3    3
    )
    first block: TensorBlock
        samples (420): ['system', 'atom']
        components (1): ['o3_mu']
        properties (400): ['neighbor_1_type', 'n_1', 'neighbor_2_type', 'n_2']
        gradients: None




.. GENERATED FROM PYTHON SOURCE LINES 103-109

.. code-block:: Python


    lambda_soap = lambda_soap.keys_to_properties(["l_1", "l_2"])

    print("λ-SOAP after keys_to_properties:", lambda_soap.keys)
    print("first block:", lambda_soap[0])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    λ-SOAP after keys_to_properties: Labels(
        o3_lambda  o3_sigma  center_type
            0         1           1
            1         1           1
                      ...
            5         -1          8
            6         1           8
    )
    first block: TensorBlock
        samples (420): ['system', 'atom']
        components (1): ['o3_mu']
        properties (1600): ['l_1', 'l_2', 'neighbor_1_type', 'n_1', 'neighbor_2_type', 'n_2']
        gradients: None




.. GENERATED FROM PYTHON SOURCE LINES 110-113

This obtains a result that is equivalent to the :math:`\lambda`-SOAP seen in the
previous tutorial. We can confirm this by computing an ``EquivariantPowerSpectrum``
and checking for consistency.

.. GENERATED FROM PYTHON SOURCE LINES 114-122

.. code-block:: Python


    equivariant_ps_calculator = EquivariantPowerSpectrum(spherical_expansion)
    equivariant_ps = equivariant_ps_calculator.compute(
        systems, neighbors_to_properties=True
    )

    assert mts.equal(lambda_soap, equivariant_ps)








.. GENERATED FROM PYTHON SOURCE LINES 123-133

Computing the bispectrum
========================

Higher body order descriptors can be computed by increasing the ``n_correlations``
parameter. The ``max_angular`` should also be increased to account for the increased
combinations in angular momenta.

With more iterations, the cost of the computation scales unfavourably. Let's use a
density with small hyper parameters to demonstrate calculation of the bispectrum, a
body-order 4 equivariant descriptor.

.. GENERATED FROM PYTHON SOURCE LINES 134-151

.. code-block:: Python


    HYPER_PARAMETERS_SMALL = {
        "cutoff": {
            "radius": 5.0,
            "smoothing": {"type": "ShiftedCosine", "width": 0.5},
        },
        "density": {
            "type": "Gaussian",
            "width": 0.3,
        },
        "basis": {
            "type": "TensorProduct",
            "max_angular": 2,
            "radial": {"type": "Gto", "max_radial": 2},
        },
    }








.. GENERATED FROM PYTHON SOURCE LINES 152-155

Taking two CG combinations of a density expanded to ``o3_lambda=2`` requires CG
coefficients computed up to ``max_angular=6``. This is given by ``(n_iterations + 1) *
max_angular_density``.

.. GENERATED FROM PYTHON SOURCE LINES 156-171

.. code-block:: Python


    # Initialize the SphericalExpansion calculator and compute the density
    spherical_expansion = SphericalExpansion(**HYPER_PARAMETERS_SMALL)
    density = spherical_expansion.compute(systems)
    density = density.keys_to_properties("neighbor_type")

    # Initialize DensityCorrelations calculator
    density_correlations = DensityCorrelations(
        n_correlations=2,
        max_angular=6,
    )

    # Compute the bispectrum
    bispectrum = density_correlations.compute(density)








.. GENERATED FROM PYTHON SOURCE LINES 172-180

There are now ``"neighbor_x_type"`` and ``"n_x"`` (which track the radial channel
indices) dimensions created by the product of feature spaces of the 3 density blocks
combined to make each bispectrum block.

For each block, its key contains dimensions tracking the angular order of blocks
combined to create it, namely ``["l_1", "l_2", "k_2", "l_3"]``. The ``"l_"``
dimensions track the angular order of the blocks from the original density, while
``"k_"`` dimensions track the angular order of intermediate blocks.

.. GENERATED FROM PYTHON SOURCE LINES 181-184

.. code-block:: Python


    print("bispectrum first block:", bispectrum[0])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    bispectrum first block: TensorBlock
        samples (420): ['system', 'atom']
        components (1): ['o3_mu']
        properties (1728): ['neighbor_1_type', 'n_1', 'neighbor_2_type', 'n_2', 'neighbor_3_type', 'n_3']
        gradients: None




.. GENERATED FROM PYTHON SOURCE LINES 185-186

Let's look at an example. Take the block at index 156:

.. GENERATED FROM PYTHON SOURCE LINES 187-190

.. code-block:: Python


    print(bispectrum.keys[156])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    LabelsEntry(o3_lambda=3, o3_sigma=1, center_type=7, l_1=1, l_2=2, k_2=1, l_3=2)




.. GENERATED FROM PYTHON SOURCE LINES 191-203

This was created in the following way.

First, a block from ``density`` of angular order ``l_1=1`` was combined with a block
of order ``l_2=2``. Angular momenta coupling rules state that non-zero combinations
can only be created for output blocks with order ``| l_1 - l_2 | <= k_2 <= | l_1 + l_2
|``, corresponding to ``[1, 2, 3]``. In this case, a block of order ``k_2=1`` was
created.

Next, this intermediate block of order ``k_2=1`` was then combined with a block from
the original density of order ``l_3=2``. This can again create combinations ``[1, 2,
3]``, and in this case has been combined to create the output angular order
``o3_lambda=3``.

.. GENERATED FROM PYTHON SOURCE LINES 207-209

As before, we can move these symmetry keys to properties and inspect the metadata and
the total size of the features.

.. GENERATED FROM PYTHON SOURCE LINES 210-215

.. code-block:: Python


    bispectrum = bispectrum.keys_to_properties(["l_1", "l_2", "k_2", "l_3"])

    print("first block:", bispectrum[0])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    first block: TensorBlock
        samples (420): ['system', 'atom']
        components (1): ['o3_mu']
        properties (8640): ['l_1', 'l_2', 'k_2', 'l_3', 'neighbor_1_type', 'n_1', 'neighbor_2_type', 'n_2', 'neighbor_3_type', 'n_3']
        gradients: None




.. GENERATED FROM PYTHON SOURCE LINES 217-222

.. code-block:: Python

    print(
        "total number of features:",
        np.sum([len(block.properties) for block in bispectrum]),
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    total number of features: 428544




.. GENERATED FROM PYTHON SOURCE LINES 223-234

Instead of computing the full CG product, a threshold can be defined to limit the
maximum angular order of blocks computed at each step in the iterative CG coupling
steps.

This is controlled by the ``angular_cutoff`` parameter, and allows us to initialize
the calculator with a lower ``max_angular``.

Note that any truncation of the angular channels away from the maximal allowed by
angular momenta coupling rules results in some loss of information.

Let's truncate to an angular cutoff of 3:

.. GENERATED FROM PYTHON SOURCE LINES 235-252

.. code-block:: Python


    angular_cutoff = 3
    density_correlations = DensityCorrelations(
        n_correlations=2,
        max_angular=angular_cutoff,
    )
    bispectrum_truncated = density_correlations.compute(
        density, angular_cutoff=angular_cutoff
    )

    # Move the "l_" and "k_" keys to properties
    bispectrum_truncated = bispectrum_truncated.keys_to_properties(
        ["l_1", "l_2", "k_2", "l_3"]
    )

    print("truncated bispectrum:", bispectrum_truncated.keys)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    truncated bispectrum: Labels(
        o3_lambda  o3_sigma  center_type
            0         1           1
            1         1           1
                      ...
            3         -1          8
            0         -1          8
    )




.. GENERATED FROM PYTHON SOURCE LINES 253-256

.. code-block:: Python


    print("first block:", bispectrum_truncated[0])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    first block: TensorBlock
        samples (420): ['system', 'atom']
        components (1): ['o3_mu']
        properties (8640): ['l_1', 'l_2', 'k_2', 'l_3', 'neighbor_1_type', 'n_1', 'neighbor_2_type', 'n_2', 'neighbor_3_type', 'n_3']
        gradients: None




.. GENERATED FROM PYTHON SOURCE LINES 257-262

.. code-block:: Python

    print(
        "total number of features:",
        np.sum([len(block.properties) for block in bispectrum_truncated]),
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    total number of features: 338688




.. GENERATED FROM PYTHON SOURCE LINES 263-269

To compute a descriptor that matches the symmetry of a given target property, the
``selected_keys`` argument can be passed to the ``compute`` method. This was also seen
in the previous tutorial on :ref:`computing lambda-SOAP <compute-lambda-soap>`.

Following this example, to compute the truncated bispectrum for a polarizability
tensor:

.. GENERATED FROM PYTHON SOURCE LINES 270-286

.. code-block:: Python

    bispectrum_truncated_key_select = density_correlations.compute(
        density,
        angular_cutoff=angular_cutoff,
        selected_keys=mts.Labels(
            ["o3_lambda", "o3_sigma"],
            np.array([[0, 1], [2, 1]]),
        ),
    )

    # Move the "l_" and "k_" keys to properties
    bispectrum_truncated_key_select = bispectrum_truncated_key_select.keys_to_properties(
        ["l_1", "l_2", "k_2", "l_3"]
    )

    print("truncated bispectrum with selected keys:", bispectrum_truncated_key_select.keys)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    truncated bispectrum with selected keys: Labels(
        o3_lambda  o3_sigma  center_type
            0         1           1
            2         1           1
                      ...
            0         1           8
            2         1           8
    )




.. GENERATED FROM PYTHON SOURCE LINES 287-293

.. code-block:: Python

    print(
        "total number of features:",
        np.sum([len(block.properties) for block in bispectrum_truncated_key_select]),
    )






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    total number of features: 103680




.. GENERATED FROM PYTHON SOURCE LINES 294-302

Conclusion
==========

``DensityCorrelations`` can be used to build equivariants of arbitrary body order from
a spherical expansion of decorated atomic point cloud data.

A key limitation of this approach is an exploding feature size. To reduce the number
of output blocks, the ``angular_cutoff`` parameter can be used.

.. GENERATED FROM PYTHON SOURCE LINES 305-306

.. end-body


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 25.947 seconds)


.. _sphx_glr_download_examples_density-correlations.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: density-correlations.ipynb <density-correlations.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: density-correlations.py <density-correlations.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: density-correlations.zip <density-correlations.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
